<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type"><title>PrologDB Package Documentation</title></head>
<body><h1 style="text-align: center; font-family: Helvetica,Arial,sans-serif;">PrologDB Package Documentation</h1><br style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">PrologDB is a Java package to read and write MDELite Prolog databases. &nbsp;The table of contents for this document is:</span><br style="font-family: Helvetica,Arial,sans-serif;"><ul style="font-family: Helvetica,Arial,sans-serif;"><li><a href="#Prolog_Database_Concepts">Prolog Database Concepts</a></li><ul><li><a href="#Database_Schemas">Database Schemas</a></li><li><a href="#Table_Schemas">Table Schemas</a></li><li><a href="#Databases_Tables_and_Tuples">Databases, Tables, and Tuples</a></li><li><a href="#Subtable_Table_Inheritance">Subtable (Table Inheritance) Declarations</a></li><li><a href="#File_Naming_Conventions">File Naming Conventions</a></li></ul><li><a href="#Java_Programming_Prolog_Databases">Java Programming Prolog Databases</a></li><ul><li><a href="#Reading_Schemas">Reading Schemas</a></li><li><a href="#Writing_Schemas">Writing Schemas</a></li><li><a href="#Reading_Databases">Reading Databases</a></li><li><a href="#Writing_Databases">Writing Databases</a></li><li><a href="#Programming_Table_Retrievals">Programming Table Retrievals</a></li><li><a href="#Programming_Table_Joins">Programming Table Joins</a></li></ul></ul><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Prolog_Database_Concepts"></a>Prolog Database Concepts</h2><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;"></span><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="Database_Schemas"></a>Database Schemas</h3><span style="font-family: Helvetica,Arial,sans-serif;">A
Prolog Database Schema declaration is a Prolog fact. &nbsp;It specifies
a database schema name and a Prolog list of table names (equivalently
table schema names) that belong to the database. &nbsp;Examples:</span><br><pre style="margin-left: 80px;">dbase( one, [t1, t2] ).<br></pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;">declares a database schema named 'one' that has table names (equivalently table schema names) t1, t2.</span></div><pre style="margin-left: 80px;">dbase( dog, [breeds,pets,owners]).<br></pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;">declares a&nbsp;database schema named 'dog' with&nbsp;table names (equivalently table schema names) breeds, pets, and owners.</span></div><pre style="margin-left: 80px;">dbase(three, [d]).<br></pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;">declares a&nbsp;database schema named 'three' that has a single table (equivalently table schema name) d.</span><br style="font-family: Helvetica,Arial,sans-serif;"></div><br style="font-family: Helvetica,Arial,sans-serif;"><a style="font-family: Helvetica,Arial,sans-serif;" name="PrologName"></a><span style="font-family: Helvetica,Arial,sans-serif;">Names
of databases and tables follow Prolog naming conventions: first letter
must be lowercase and remaining characters are letters or digits or '_'.</span><br style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Helvetica,Arial,sans-serif;"><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="Table_Schemas"></a>Table Schemas</h3><span style="font-family: Helvetica,Arial,sans-serif;">A
table schema declaration is another Prolog fact. &nbsp;It specifies a
table schema name and a Prolog list of column declarations. &nbsp;A
column declaration is a </span><a style="font-family: Helvetica,Arial,sans-serif;" href="#PrologName">Prolog name</a><span style="font-family: Helvetica,Arial,sans-serif;">; a value of a column is one of two types of Prolog atoms: </span><br style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (T1) a </span><a style="font-family: Helvetica,Arial,sans-serif;" href="#PrologName">name</a><span style="font-family: Helvetica,Arial,sans-serif;"> (ex: don) or a number (float or integer) </span><br style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">OR </span><br style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; (T2) a single-quoted list (e.g. 'Taco' or 'some atom'). &nbsp;</span><br><br style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">If
a column name N is un-quoted, the column values are of type (1); if
a column name is double quoted, as in "N", column values are of type
(2). Examples:</span><br><pre style="margin-left: 80px;"><a name="TableExample"></a>table( breeds, [id,"dogBreed"] ).<br></pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;">declares
a table schema named breeds with 2 columns whose names are id and
dogBreed. &nbsp;Column id is of type (T1) and dogBreed is of type
(T2).</span><br></div><pre style="margin-left: 80px;">table ( t2, [ident, "name", age]).<br></pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;">declares
a table schema named t2 with 3 columns whose names are ident, name,
age. &nbsp;Column ident is of type (T1), name is of type (T2), and age
is of type (T1).</span></div><pre style="margin-left: 80px;">table( t3, [i,a,b,c]).<br></pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;">declares a table schema named t3 with 4 columns whose names are i,a,b,c. &nbsp;All columns are of type (T2).</span><br style="font-family: Helvetica,Arial,sans-serif;"></div><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="Databases_Tables_and_Tuples"></a>Databases, Tables and Tuples</h3><span style="font-family: Helvetica,Arial,sans-serif;">When
a database schema is instantiated, a table is created for each table
schema. &nbsp;The name of each table is exactly the same as the name of
its table schema. &nbsp;Tables are populated by tuples (a.k.a. "rows").
&nbsp;Consider the </span><a style="font-family: Helvetica,Arial,sans-serif;" href="#TableExample">table schema declaration from above:</a><br><pre style="margin-left: 40px;">table(breeds,[id,"name"]).</pre><span style="font-family: Helvetica,Arial,sans-serif;">A
tuple declaration is a Prolog fact having the name of the table and a
value for each of the table columns -- listed in the order they
were defined in the table schema. Here are 3 tuples that belong to the
breeds table:</span><br><pre style="margin-left: 40px;">breeds(1,'Australian Shepherd').<br>breeds(2,'Doberman').<br>breeds(3,'Blood Hound').<br></pre><span style="font-family: Helvetica,Arial,sans-serif;">Below is shown a declaration of a simple database with 3 tuples for the breeds table and 4 tuples in the pets table:</span><br><pre style="margin-left: 40px;"><span style="color: red;">:-style_check(-discontiguous).</span><br><br>dbase(dog,[breeds,pets,owners]).<br><br>table(breeds,[bid,"name"]).<br>breeds(b1,'Australian Shepherd').<br>breeds(b2,'Doberman').<br>breeds(b3,'Blood Hound').<br><br>table(pets,[pid,"petName",breedId]).<br>pets(p1,'Kelsey",b1).<br>pets(p2,'Duke",b3).<br>pets(p3,'ChiliDog",b1).<br>pets(p4,'Hershey',b2).<br><br>table(owners,[oid,"name"]).<br>:- dynamic owners/2.<br></pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">Note</span>:
style_check is a Prolog rule that says facts in this file are unsorted,
and not to generate an unsorted error. &nbsp;Example: table facts are
not consecutive, whereas pets facts are.<br><br><span style="font-weight: bold;">Note</span>:
that Prolog does not natively understand table schema declarations.
&nbsp;We are
using Prolog to encode this information as Prolog facts. A consequence
is that
we have to use ":- dynamic&nbsp;owners/2." to declare empty tables
explicitly. &nbsp;The reason is that Prolog does not natively
distinguish the concept of "undefined" from "unpopulated" or "no
instances". &nbsp;The "dynamic owners" declaration makes this
distinction.<br></span></div><span style="font-family: Helvetica,Arial,sans-serif;"><br>As
a general design guideline, the first column of every tuple (the
first column of every table) is an identifier -- meaning that no other
tuple in that table has that identifier. &nbsp;As in databases, an
identifier is unique to a tuple and (effectively) is a pointer to that
tuple. &nbsp;Thus, column bid is the identifier of the breeds table;
pid is the identifier of the pets table. &nbsp;The breedId column (in
this example) contains breed identifiers. &nbsp;So the 'Kelsey' tuple
has breedId b1, which means that 'Kelsey' is an 'Australian Sheperd'.
&nbsp;And&nbsp;'Hershey' &nbsp;is a 'Doberman'. The oowners table has
no tuples. &nbsp;This is indicated in prolog by the statement ":-
dynamic owners/2." &nbsp;The slash 2 means owners has two columns.</span><br style="font-family: Helvetica,Arial,sans-serif;"><br><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="Subtable_Table_Inheritance"></a>Subtable (Table Inheritance) Declarations</h3><span style="font-family: Helvetica,Arial,sans-serif;">Tables can be in an inheritance relationship, which is declared by a subtable declaration. Examples:</span><br><pre style="margin-left: 80px;">subtable(a,[b,c]).<br></pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;">Table a has two subtables b and c.</span><br></div><pre style="margin-left: 80px;">subtable(chocolateCake,[birthdayCake]).<br></pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;">Table chocolateCake has a single subtable birthdayCake.</span><br style="font-family: Helvetica,Arial,sans-serif;"></div><br style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">Here
is a simple database schema called starTrek with three tables: crewman,
commander (which is a subtable of crewman), and lieutenant (another
subtable of crewman):</span><br><pre style="margin-left: 40px;">dbase(starTrek,[crewman, commander, lieutenant]).<br><br>table(crewman,[cid,fname,lname]).<br>table(commander,[rank]).<br>table(lieutenant,[specialty]).<br><br>subtable(crewman,[commander,lieutenant]).<br></pre><span style="font-family: Helvetica,Arial,sans-serif;">Here's
what the above means: every commander tuple and every lieutenant tuple
is also a crewman tuple. just as you would expect in Java with the
class hierarchy:</span><br><pre style="margin-left: 40px;">class crewman { String id, fname, lname; }<br>class commander extends crewman { String rank; }<br>class lieutenant extends crewman { String speciality; }<br></pre><span style="font-family: Helvetica,Arial,sans-serif;">Each subtable declaration (e.g., commander and lieutenant) lists the columns that are in ADDITION to those in crewman. &nbsp;</span><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;">Only when a starTrek database is instantiated will columns be propagated from parent-table to child-table.</span><span style="font-family: Helvetica,Arial,sans-serif;"> &nbsp; This is called "<span style="font-weight: bold; color: red;">flattening</span>". A instance of the starTrek database -- of course, flattened --&nbsp; is shown below:</span><br><pre style="margin-left: 40px;"><a name="starTrekDB"></a><span style="color: red;"><span style="color: black;">:-style_check(-discontiguous).</span><br><br></span>dbase(starTrek,[crewman, commander, lieutenant]).<br><br>table(crewman,[cid,fname,lname]).<br>crewman(c1,mr,spock).<br><br>table(commander,[cid,fname,lname,rank]).<br>commander(c2,james,kirk,captain).<br><br>table(lieutenant,[cid,fname,lname,specialty]).<br>lieutenant(c3,hikaru,sulu,navigation).<br><br>subtable(crewman,[commander,lieutenant]).</pre><div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">Note</span>: The columns cid,fname,lname of the crewman table have been
propagated to the subtables commander and lieutenant. &nbsp;The reason
for this is to make explict the set of columns each table has, so that
it is easier to verify tuple have the right sequence of values.</span><br><span style="font-family: Helvetica,Arial,sans-serif;"></span><br><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">Note</span>:
Always create a schema BEFORE you instantiate it. &nbsp;(This is Java
common sense transported to the Prolog database world). &nbsp;Never
ever create a schema s, then create a database instance of s, and then
change s. &nbsp;All of s's previously instantiated databases will not
respect these updates. &nbsp;</span><br style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></div><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="File_Naming_Conventions"></a>File Naming Conventions</h3><span style="font-family: Helvetica,Arial,sans-serif;">A
Prolog database schema (which includes dbase, 1 or more table schemas,
and 0 or more subtable declarations) are stored in a single Prolog file
with name X.schema.pl, where X is typically (but not required to be)
the name of the dbase schema. Example:</span><br><pre style="margin-left: 40px;">starTrek.schema.pl<br></pre><span style="font-family: Helvetica,Arial,sans-serif;">Is
the name of the starTrek schema file. Note that if we know that we are
reading a schema file, "starTrek" is sufficient -- we can infer
".schema.pl".</span><br style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">A Prolog database (which includes
column-propagated tables according to subtable inheritance
declarations) are stored in a single Prolog file with name:
&nbsp;D.X.pl, where "D" is the name of the database instance, "X" is
the name of the name of the database schema, and "pl" indicates that
the file is a Prolog file. Example:</span><br><pre style="margin-left: 40px;">enterprise.starTrek.pl<br></pre><span style="font-family: Helvetica,Arial,sans-serif;">Is a file name that contains the </span><a style="font-family: Helvetica,Arial,sans-serif;" href="#starTrekDB">starTrek database given above.</a><span style="font-family: Helvetica,Arial,sans-serif;">
&nbsp;Note that if we know that we are reading a database file,
"enterprise.starTrek" is sufficient -- we can infer the trailing ".pl".
</span><br style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">In this way, schema files and differentiated from their database instance files.</span><br style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Helvetica,Arial,sans-serif;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Java_Programming_Prolog_Databases"></a>Java Programming Prolog Databases</h2><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="Reading_Schemas"></a>Reading Schemas</h3><span style="font-family: Helvetica,Arial,sans-serif;">The
Java PrologDB package exports a set of classes that you can use to read
and write Prolog schemas and databases. &nbsp;The class structure for
schemas is obvious:</span><br style="font-family: Helvetica,Arial,sans-serif;"><ul style="font-family: Helvetica,Arial,sans-serif;"><li>a DBSchema object has</li><ul><li>a name</li><li>a list of TableSchemas &nbsp;(one per.table declaration)</li><ul><li>a table schema name</li><li>a list of (named) columns</li></ul><li>a list of SubTableSchemas (one per subtable declaration)</li><ul><li>a parent table&nbsp;schema</li><li>a list of each of its subtable schemas</li></ul></ul><ul><li>boolean
indicating if the schema has been "flattened"; schemas read from a
.schema.pl file are not flattened. &nbsp;Schemas extracted from a
Prolog database are flattened.</li></ul></ul><span style="font-family: Helvetica,Arial,sans-serif;">There are obvious getters and setters for each structure. Look at the program below (left) and its output (right):</span><br><br><table style="text-align: left; height: 553px; width: 1049px;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="font-family: Helvetica,Arial,sans-serif; font-weight: bold; text-align: center; width: 646px;">Program</td><td style="font-family: Helvetica,Arial,sans-serif; font-weight: bold; text-align: center; width: 383px;">Output</td></tr><tr><td style="width: 646px;"><pre><span style="font-family: monospace;">try {<br>   &nbsp;&nbsp;&nbsp;&nbsp; File sFile = new File("TestData/Schema/starTrek.schema.pl");<br>   &nbsp;&nbsp;&nbsp;&nbsp; DBSchema s = DBSchema.readSchema(sFile, System.err);<br>   &nbsp;&nbsp;&nbsp;&nbsp; // easy way<br>   &nbsp;&nbsp;&nbsp;&nbsp; s.print(System.out);<br><br>   &nbsp;&nbsp;&nbsp;&nbsp; // more detailed way<br>   &nbsp;&nbsp;&nbsp;&nbsp; System.out.format("\n\n=========\n\n", null);<br>   &nbsp;&nbsp;&nbsp;&nbsp; System.out.format("database %s has \n", s.getName());<br>   &nbsp;&nbsp;&nbsp;&nbsp; for (TableSchema t : s.getTableSchemas()) {<br>      &nbsp; System.out.format("&nbsp;&nbsp; table %s with columns ", t.getName());<br>      &nbsp; for (Column c : t.getColumns()) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char quote = c.isQuoted() ? '\'' : ' ';<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.format("%c%s%c ", quote, c.getName(), quote);<br>      &nbsp; }<br>      &nbsp; System.out.format("\n");<br>   &nbsp;&nbsp;&nbsp;&nbsp; }<br>   &nbsp;&nbsp;&nbsp;&nbsp; System.out.format("\n");<br>   &nbsp;&nbsp;&nbsp;&nbsp; for (SubTableSchema st : s.getSubTableSchemas()) {<br>      &nbsp; TableSchema supr = st.getSuper();<br>      &nbsp; System.out.format("&nbsp;&nbsp; table %s has subtables ", supr.getName());<br>      &nbsp; for (TableSchema chld : st.getSubTableSchemas()) {<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.format("%s ", chld.getName());<br>      &nbsp; }<br>      &nbsp; System.out.format("\n");<br>   &nbsp;&nbsp;&nbsp;&nbsp; }<br>   &nbsp;&nbsp;&nbsp;&nbsp; System.out.format("\n\n");<br><br>    } catch (Exception e) {<br>   &nbsp;&nbsp;&nbsp;&nbsp; System.err.println(e.getMessage());<br>    }</span></pre></td><td style="width: 383px;"><pre style="width: 337px;">dbase(starTrek,[crewman,commander,lieutenant]).<br></pre><pre style="width: 337px;"><br>table(crewman,[cid,fname,lname]).<br>table(commander,[rank]).<br>table(lieutenant,[specialty]).<br><br>subtable(crewman,[commander,lieutenant]).<br><br><br>=========<br><br>database starTrek has <br>table crewman with columns  cid   fname   lname  <br>table commander with columns  rank  <br>table lieutenant with columns  specialty  <br>table crewman has subtables commander lieutenant<br>&nbsp;</pre></td></tr></tbody></table><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="Writing_Schemas"></a>Writing Schemas</h3><span style="font-family: Helvetica,Arial,sans-serif;">Suppose
you want to programmatically create the starTrek database schema from
scratch. &nbsp;Here's a program that does this (below
left), along with its output (below right).<br></span><table style="text-align: left; width: 100px;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td><pre><a name="enterpriseSchemaBuild"></a>public void testSchemaBuild() {<br>   try {<br>     DBSchema trekSchema = new DBSchema("starTrek");<br><br>     // create tables and add them to the schema<br>     TableSchema crewman = new TableSchema("crewman");<br>     {<br>        crewman.addColumn(new Column("cid", false));  // false means non-quoted<br>        crewman.addColumn(new Column("fname", false));<br>        crewman.addColumn(new Column("fname", false));<br>     }<br>     TableSchema commander = new TableSchema("commander");<br>     {<br>        commander.addColumn(new Column("rank", false));<br>     }<br>     TableSchema lieutenant = new TableSchema("lieutenant");<br>     {<br>        lieutenant.addColumn(new Column("specialty",false));<br>     }<br>     trekSchema.addTableSchema(crewman);<br>     trekSchema.addTableSchema(commander);<br>     trekSchema.addTableSchema(lieutenant);<br><br>     // now createe the lone subtable declaration, and add to schema<br>     SubTableSchema sts = new SubTableSchema(crewman);<br>     sts.addSubTableSchema(commander);<br>     sts.addSubTableSchema(lieutenant);<br>     trekSchema.addSubTableSchema(sts);<br><br>     // now print the schema declaration<br>     trekSchema.print(System.out);<br>  } catch (Exception e) {<br>     System.err.println(e.getMessage());<br>  }<br>}</pre></td><td><pre>dbase(starTrek,[crewman,commander,lieutenant]).<br><br>table(crewman,[cid,fname,fname]).<br>table(commander,[rank]).<br>table(lieutenant,[specialty]).<br><br>subtable(crewman,[commander,lieutenant]).</pre></td></tr></tbody></table><span style="font-family: Helvetica,Arial,sans-serif;"><br></span><h3><a name="Reading_Databases"></a><span style="font-family: Helvetica,Arial,sans-serif;">Reading Databases</span></h3><span style="font-family: Helvetica,Arial,sans-serif;">Suppose you want to read the </span><a style="font-family: Helvetica,Arial,sans-serif;" href="#starTrekDB">enterprise database previously defined</a><span style="font-family: Helvetica,Arial,sans-serif;">, which is stored in file "enterprise.starTrek.pl". &nbsp;Here's how to read it and print its tuples:</span><br><table style="text-align: left; width: 100px;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="font-family: Helvetica,Arial,sans-serif; font-weight: bold; text-align: center;">Program</td><td style="font-family: Helvetica,Arial,sans-serif; font-weight: bold; text-align: center;">Output</td></tr><tr><td><pre>try {<br>   File dbfile = new File("TestData/DB/enterprise.starTrek.pl");<br>   DB db = DB.readDataBase(dbfile,System.err);<br>   // easy way to print<br>   db.print(System.out);<br>      // more detailed way<br>   System.out.format("\n\n ===== \n\n",null);<br>   System.out.format("database %s contains:\n", db.getName());<br>      for (Table t : db.getTables()){<br>   System.out.format("Table %s\n",t.getName());<br>   for (Tuple tup : t.getTuples()) {<br>       tup.print(System.out);<br>   }<br>   System.out.format("\n",null);<br>   }<br>} catch (Exception e) {<br>   System.err.println(e.getMessage());<br>}</pre></td><td><pre>database enterprise contains:<br>Table crewman<br>crewman(c1,mr,spock).<br><br>Table commander<br>commander(c2,james,kirk,captain).<br><br>Table lieutenant<br>lieutenant(c3,hikaru,sulu,navigation).</pre></td></tr></tbody></table><br><span style="font-family: Helvetica,Arial,sans-serif;">Now,
the starTrek database has no inheritance relationships among tables.
&nbsp;This allows you to invoke the getTuples method directly on the
table itself. &nbsp;But with inheritance, tuples of subtables would not
be retrieved. &nbsp;So a more general strategy is for you to use the DB
methods:</span><br style="font-family: Helvetica,Arial,sans-serif;"><ul style="font-family: Helvetica,Arial,sans-serif;"><li>Tuple
findFirst(String tableName, String column, String value) // finds first
tuple where column = value in the table with given name and its
subtables</li><li>Tuple findFirst(Table table, String column, String value) &nbsp; //&nbsp;finds first tuple where column = value in the given table and its subtables</li><li>List&lt;Tuple&gt;
find(String tableName, String column, String value) // finds all tuples
where column = value in the table with given name and its subtables</li><li>List&lt;Tuple&gt;
find(Table tbl, String column, String value) &nbsp;// finds all tuples
where column = value in the given table and its subtables</li><li>List&lt;Tuple&gt; getTuples(String tableName)&nbsp;// returns all tuples in the table with the given name and its subtables</li><li>List&lt;Tuple&gt; getTuples(Table tbl) &nbsp;// returns all tuples in given table and its subtables</li></ul><span style="font-family: Helvetica,Arial,sans-serif;">Note
that when tuples of subtables are produced, they are trimmed of all
columns that do not belong to the target table. &nbsp;This is
illustrated in the program below. &nbsp;Here is a database of three
tables with an inheritance relationship:</span><br><pre style="margin-left: 40px;">:-style_check(-discontiguous).<br><br>dbase(petdb,[pet,cat,dog).<br><br>table(pet,[did,"name"]).<br>pet(d0,'dumbo').<br>pet(d00,'nemo').<br><br>table(dog,[did,"name","breed", color]).<br>dog(d1,'kelsey','aussie',bluemerle).<br>dog(d2,'lassie','collie',sable).<br>dog(d3,'scarlett','aussie',blacktri).<br>dog(d4,'duke','hound dog',brown).<br><br>table(cat,[did,"name","type"]).<br>cat(d5,'tigger','bengal').<br>cat(d6,'lucy','tabby').<br><br>subtable(pet,[dog,cat]).</pre><span style="font-family: Helvetica,Arial,sans-serif;">Here
is a program that (1) retrieves all pets, (2) retrieves all pets whose
name begins with "l". &nbsp;Note that pet tuples may belong to
subtables, but columns that are not part of the pet table are
removed&nbsp;-- this is a standard database concept. &nbsp;Note also
that DB, rather than Table operations are performed to get tuples of
subtables.</span><br><br><table style="text-align: left; width: 100px;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;">Program</td><td style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;">Output</td></tr><tr><td><pre>DB db = DB.readDataBase("TestData/DB/pet.petdb.pl");<br>Table pet = db.findTable("pet");<br><br>// query 1: retrieve all pets<br>List&lt;Tuple&gt; allPets = db.getTuples(pet);<br>Tuple.print(allPets, "list of all pets", System.out);<br><br>// query 2: all pets whose name begins with "l"<br>System.out.println("list of all pets whose names start with 'l'");<br>for (Tuple t : allPets) {<br>   if (t.getValue("name").startsWith("l")) {<br>       t.print(System.out);<br>   }<br>}</pre></td><td><pre>list of all pets<br>pet(d0,'dumbo').<br>pet(d00,'nemo').<br>pet(d1,'kelsey').<br>pet(d2,'lassie').<br>pet(d3,'scarlett').<br>pet(d4,'duke').<br>pet(d5,'tigger').<br>pet(d6,'lucy').<br><br>list of all pets whose names start with 'l'<br>pet(d2,'lassie').<br>pet(d6,'lucy').</pre></td></tr></tbody></table><br><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="Writing_Databases"></a>Writing Databases</h3><span style="font-family: Helvetica,Arial,sans-serif;">Now suppose you wanted to populate the starTrek schema tables with tuples. &nbsp;Here's how:<br></span><table style="text-align: left; width: 100px;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="font-family: Helvetica,Arial,sans-serif; font-weight: bold; text-align: center;">Program</td><td style="font-family: Helvetica,Arial,sans-serif; font-weight: bold; text-align: center;">Output</td></tr><tr><td><pre> DBSchema trekSchema = <a href="#enterpriseSchemaBuild">schemaBuild()</a>; // follow link to defn.<br> DB enterprise = new DB("enterprise",trekSchema);<br><br> // create spock tuple<br> Table crewman = enterprise.findTableEH("crewman");<br> Tuple spock = new Tuple(crewman);<br> spock.addColumnValuesEH("c1", "mr","spock");<br> crewman.addTuple(spock);<br><br> // create sulu tuple<br> Table lieutenant = enterprise.findTableEH("lieutenant");<br> Tuple sulu = new Tuple(lieutenant);<br> sulu.addColumnValuesEH("c3", "hikaru", "sulo", "navigation");<br> lieutenant.addTuple(sulu);<br><br> // create kirk tupld<br> Table commander = enterprise.findTableEH("commander");<br> Tuple kirk = new Tuple(commander);<br> kirk.addColumnValuesEH("c2", "james", "kirk", "captain");<br> commander.addTuple(kirk);<br><br> // now print database<br> enterprise.print(System.out);</pre></td><td><pre>:-style_check(-discontiguous).<br><br>dbase(starTrek,[crewman,commander,lieutenant]).<br><br>table(crewman,[cid,fname,lname]).<br>crewman(c1,mr,spock).<br><br>table(commander,[cid,fname,lname,rank]).<br>commander(c2,james,kirk,captain).<br><br>table(lieutenant,[cid,fname,lname,specialty]).<br>lieutenant(c3,hikaru,sulo,navigation).<br><br>subtable(crewman,[commander,lieutenant]).</pre></td></tr></tbody></table><br><span style="font-family: Helvetica,Arial,sans-serif;">Note
that methods whose names end in EH have a counterpart method that does
not end in EH. &nbsp;"EH" means error handling. &nbsp;For example, in
the above program you will see the operation addColumnValuesEH.
&nbsp;If a column is defined more than once, an exception is thrown.
&nbsp;addColumnValuesEH catches that error and essentially terminates
the program. &nbsp;If your program wants to handle this error yourself,
call the addColumnValue() method.</span><br><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="Programming_Table_Retrievals"></a>Programming Table Retrievals</h3><span style="font-family: Helvetica,Arial,sans-serif;">Single table retrievals are simple. </span><span style="font-family: Helvetica,Arial,sans-serif;">Here is the dogOwner database, which has three tables that relate dogs to their owners at different times:</span><br><pre style="margin-left: 40px;">:-style_check(-discontiguous).<br><br>dbase(do,[dog,owner,when]).<br><br>table(dog,[did,"name","breed", color]).<br>dog(d1,'kelsey','aussie',bluemerle).<br>dog(d2,'lassie','collie',sable).<br>dog(d3,'scarlett','aussie',blacktri).<br>dog(d4,'duke','hound dog',brown).<br><br>table(owner,[oid,"name"]).<br>owner(o1,'timmy').<br>owner(o2,'don').<br>owner(o3,'helen').<br>owner(o4,'jed').<br><br>table(when,[wid,did,oid,"date"]).<br>when(w1,d1,o2,'88-95').<br>when(w2,d2,o1,'58-71').<br>when(w3,d3,o3,'07-12').<br>when(w4,d3,o2,'12-').<br>when(w5,d4,o4,'58-69').</pre><span style="font-family: Helvetica,Arial,sans-serif;">The
first-part of the program below shows how to retrieve all tuples from
the dog table where the breed is "aussie". &nbsp;A find(col,val) call
returns a list of tuples where the column (col) has value (val).
&nbsp;In this case, column "breed" has value "aussie". &nbsp;If you to
further restrict this list, you can use a subsequent find (shown in the
last-part of the program) to eliminate "aussie" tuples whose "color" is
"blacktri".<br><br></span><table style="text-align: left; width: 100px;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="text-align: center; font-family: Helvetica,Arial,sans-serif; font-weight: bold;">Program</td><td style="text-align: center; font-family: Helvetica,Arial,sans-serif; font-weight: bold;">Output</td></tr><tr><td><pre>DB db = DB.readDataBase("TestData/DB/dogOwner.do.pl");<br>Table dog = db.findTable("dog");<br><br>// query 1: retrieve all aussies<br>List&lt;Tuple&gt; aussies = dog.find("breed", "aussie");<br>Tuple.print(aussies, "list of aussies", System.out);<br><br>// query 2: retrieve all aussies that are blacktri's<br>//       use prior list as starting point<br>List&lt;Tuple&gt; kaussies = dog.find(aussies, "color", "blacktri");<br>Tuple.print(kaussies, "list of black tri aussies", System.out);</pre></td><td><pre>list of aussies<br>dog(d1,'kelsey','aussie',bluemerle).<br>dog(d3,'scarlett','aussie',blacktri).<br><br>list of black tri aussies<br>dog(d3,'scarlett','aussie',blacktri).</pre></td></tr></tbody></table><br><h3 style="font-family: Helvetica,Arial,sans-serif;"><a name="Programming_Table_Joins"></a>Programming Table Joins</h3><span style="font-family: Helvetica,Arial,sans-serif;">Joining tables is common in databases. &nbsp;Suppose we want to pair dogs with their owners. &nbsp;</span><span style="font-family: Helvetica,Arial,sans-serif;">To
create a tuple that encodes this information, in database terminology
we join the dog table with the when table (over column did) and then
join with table owner (over column oid). &nbsp;As we are not interested
in when a dog was owned by a person, we simply "join" related dog and
owner tuples. &nbsp;The program below follows the procedure:<br></span><ol><li><span style="font-family: Helvetica,Arial,sans-serif;">create the table schema which is a join (or concatenation) of the dog and owner schemas. &nbsp;<span style="font-weight: bold;">You MUST create this schema before you can produce any joined tuples!</span></span></li><li><span style="font-family: Helvetica,Arial,sans-serif;">Table
joins can always be produced via nested loops, where a tuple of one
table is paired (joined) with another if their keys match. &nbsp;For
the dog table join when table, the join key/column is "did"; for the dog_x_when
join owner, the join key/column is "oid". &nbsp;Step 3 produces a tuple
of the schema dXoSchema (which is the join of the dog and owner
schemas), and the join() operation concatenates the dog tuple and owner
tuple into a dXoSchema tuple. &nbsp;Step 4 displays the join schema and
then its tuples.<br></span></li></ol><table style="text-align: left; width: 100px;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;">Program</td><td style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;">Output</td></tr><tr><td><pre>DB db = DB.readDataBase("TestData/DB/dogOwner.do.pl");<br><br>// Step 1: join the dog and owner schemas<br>TableSchema dogSchema = db.getTableSchema("dog");<br>TableSchema ownerSchema = db.getTableSchema("owner");<br>TableSchema dXoSchema = dogSchema.join(ownerSchema);<br><br>// Step 2: get the tables to join<br>Table dog = db.findTable("dog");<br>Table when = db.findTable("when");<br>Table owner = db.findTable("owner");<br><br>// Step 3: join all 3 tables and produce dXoSchema tuples as output<br>LinkedList&lt;Tuple&gt; list = new LinkedList&lt;&gt;();<br>for (Tuple d : dog.getTuples()) {<br>   for (Tuple w : when.find("did", d.getValue("did"))) {<br>       for (Tuple o : owner.find("oid", w.getValue("oid"))) {<br>           Tuple t = new Tuple(dXoSchema).join(dXoSchema, d, o);<br>           list.add(t);<br>       }<br>   }<br>}<br><br>// Step 4: print list<br>dXoSchema.print(System.out);<br>Tuple.print(list, "joined dog and owner tuples", System.out);<br></pre></td><td><pre>table(dog_x_owner,[dog_did,"dog_name","dog_breed",dog_color,owner_oid,"owner_name"]).<br><br>joined dog and owner tuples<br>dog_x_owner(d1,'kelsey','aussie',bluemerle,o2,'don').<br>dog_x_owner(d2,'lassie','collie',sable,o1,'timmy').<br>dog_x_owner(d3,'scarlett','aussie',blacktri,o3,'helen').<br>dog_x_owner(d3,'scarlett','aussie',blacktri,o2,'don').<br>dog_x_owner(d4,'duke','hound dog',brown,o4,'jed').<br></pre></td></tr></tbody></table><span style="font-family: Helvetica,Arial,sans-serif;"></span></body></html>